/** Autogenerated file. Do not edit. */
using Jacdac;
using System;

namespace Jacdac.Clients 
{
    /// <summary>
    /// Runs machine learning models.
     /// 
     /// Only models with a single input tensor and a single output tensor are supported at the moment.
     /// Input is provided by Sensor Aggregator service on the same device.
     /// Multiple instances of this service may be present, if more than one model format is supported by a device.
    /// Implements a client for the Model Runner service.
    /// </summary>
    /// <seealso cref="https://microsoft.github.io/jacdac-docs/services/modelrunner/" />
    public partial class ModelRunnerClient : Client
    {
        public ModelRunnerClient(JDBus bus, string name)
            : base(bus, name, ServiceClasses.ModelRunner)
        {
        }

        /// <summary>
        /// Reads the <c>auto_invoke_every</c> register value.
        /// When register contains `N > 0`, run the model automatically every time new `N` samples are collected.
        /// Model may be run less often if it takes longer to run than `N * sampling_interval`.
        /// The `outputs` register will stream its value after each run.
        /// This register is not stored in flash., 
        /// </summary>
        public uint AutoInvokeEvery
        {
            get
            {
                return (uint)this.GetRegisterValue((ushort)ModelRunnerReg.AutoInvokeEvery, ModelRunnerRegPack.AutoInvokeEvery);
            }
            set
            {
                
                this.SetRegisterValue((ushort)ModelRunnerReg.AutoInvokeEvery, ModelRunnerRegPack.AutoInvokeEvery, value);
            }

        }

        /// <summary>
        /// Reads the <c>last_run_time</c> register value.
        /// The time consumed in last model execution., _: us
        /// </summary>
        public uint LastRunTime
        {
            get
            {
                return (uint)this.GetRegisterValue((ushort)ModelRunnerReg.LastRunTime, ModelRunnerRegPack.LastRunTime);
            }
        }

        /// <summary>
        /// Reads the <c>allocated_arena_size</c> register value.
        /// Number of RAM bytes allocated for model execution., _: B
        /// </summary>
        public uint AllocatedArenaSize
        {
            get
            {
                return (uint)this.GetRegisterValue((ushort)ModelRunnerReg.AllocatedArenaSize, ModelRunnerRegPack.AllocatedArenaSize);
            }
        }

        /// <summary>
        /// Reads the <c>model_size</c> register value.
        /// The size of the model in bytes., _: B
        /// </summary>
        public uint ModelSize
        {
            get
            {
                return (uint)this.GetRegisterValue((ushort)ModelRunnerReg.ModelSize, ModelRunnerRegPack.ModelSize);
            }
        }

        /// <summary>
        /// Reads the <c>last_error</c> register value.
        /// Textual description of last error when running or loading model (if any)., 
        /// </summary>
        public string LastError
        {
            get
            {
                return (string)this.GetRegisterValue((ushort)ModelRunnerReg.LastError, ModelRunnerRegPack.LastError);
            }
        }

        /// <summary>
        /// Reads the <c>format</c> register value.
        /// The type of ML models supported by this service.
        /// `TFLite` is flatbuffer `.tflite` file.
        /// `ML4F` is compiled machine code model for Cortex-M4F.
        /// The format is typically present as first or second little endian word of model file., 
        /// </summary>
        public ModelRunnerModelFormat Format
        {
            get
            {
                return (ModelRunnerModelFormat)this.GetRegisterValue((ushort)ModelRunnerReg.Format, ModelRunnerRegPack.Format);
            }
        }

        /// <summary>
        /// Reads the <c>format_version</c> register value.
        /// A version number for the format., 
        /// </summary>
        public uint FormatVersion
        {
            get
            {
                return (uint)this.GetRegisterValue((ushort)ModelRunnerReg.FormatVersion, ModelRunnerRegPack.FormatVersion);
            }
        }

        /// <summary>
        /// Tries to read the <c>parallel</c> register value.
        /// If present and true this service can run models independently of other
        /// instances of this service on the device., 
        /// </summary>
        bool TryGetParallel(out bool value)
        {
            object[] values;
            if (this.TryGetRegisterValues((ushort)ModelRunnerReg.Parallel, ModelRunnerRegPack.Parallel, out values)) 
            {
                value = (bool)values[0];
                return true;
            }
            else
            {
                value = default(bool);
                return false;
            }
        }


        
        /// <summary>
        /// Open pipe for streaming in the model. The size of the model has to be declared upfront.
        /// The model is streamed over regular pipe data packets.
        /// The format supported by this instance of the service is specified in `format` register.
        /// When the pipe is closed, the model is written all into flash, and the device running the service may reset.
        /// </summary>
        public void SetModel(uint model_size)
        {
            this.SendCmdPacked((ushort)ModelRunnerCmd.SetModel, ModelRunnerCmdPack.SetModel, new object[] { model_size });
        }

    }
}