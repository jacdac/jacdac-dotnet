/** Autogenerated file. Do not edit. */
using Jacdac;
using System;

namespace Jacdac.Clients 
{
    /// <summary>
    /// A power-provider service.
    /// Implements a client for the Power service.
    /// </summary>
    /// <seealso cref="https://microsoft.github.io/jacdac-docs/services/power/" />
    public partial class PowerClient : SensorClient
    {
        public PowerClient(JDBus bus, string name)
            : base(bus, name, ServiceClasses.Power)
        {
        }

        /// <summary>
        /// Reads the <c>allowed</c> register value.
        /// Can be used to completely disable the service.
        /// When allowed, the service may still not be providing power, see 
        /// `power_status` for the actual current state., 
        /// </summary>
        public bool Allowed
        {
            get
            {
                return (bool)this.GetRegisterValueAsBool((ushort)PowerReg.Allowed, PowerRegPack.Allowed);
            }
            set
            {
                
                this.SetRegisterValue((ushort)PowerReg.Allowed, PowerRegPack.Allowed, value);
            }

        }

        /// <summary>
        /// Tries to read the <c>max_power</c> register value.
        /// Limit the power provided by the service. The actual maximum limit will depend on hardware.
        /// This field may be read-only in some implementations - you should read it back after setting., _: mA
        /// </summary>
        bool TryGetMaxPower(out uint value)
        {
            object[] values;
            if (this.TryGetRegisterValues((ushort)PowerReg.MaxPower, PowerRegPack.MaxPower, out values)) 
            {
                value = (uint)values[0];
                return true;
            }
            else
            {
                value = default(uint);
                return false;
            }
        }
        
        /// <summary>
        /// Sets the max_power value
        /// </summary>
        public void SetMaxPower(uint value)
        {
            this.SetRegisterValue((ushort)PowerReg.MaxPower, PowerRegPack.MaxPower, value);
        }


        /// <summary>
        /// Reads the <c>power_status</c> register value.
        /// Indicates whether the power provider is currently providing power (`Powering` state), and if not, why not.
        /// `Overprovision` means there was another power provider, and we stopped not to overprovision the bus., 
        /// </summary>
        public PowerPowerStatus PowerStatus
        {
            get
            {
                return (PowerPowerStatus)this.GetRegisterValue((ushort)PowerReg.PowerStatus, PowerRegPack.PowerStatus);
            }
        }

        /// <summary>
        /// Tries to read the <c>current_draw</c> register value.
        /// Present current draw from the bus., _: mA
        /// </summary>
        bool TryGetCurrentDraw(out uint value)
        {
            object[] values;
            if (this.TryGetRegisterValues((ushort)PowerReg.CurrentDraw, PowerRegPack.CurrentDraw, out values)) 
            {
                value = (uint)values[0];
                return true;
            }
            else
            {
                value = default(uint);
                return false;
            }
        }

        /// <summary>
        /// Tries to read the <c>battery_voltage</c> register value.
        /// Voltage on input., _: mV
        /// </summary>
        bool TryGetBatteryVoltage(out uint value)
        {
            object[] values;
            if (this.TryGetRegisterValues((ushort)PowerReg.BatteryVoltage, PowerRegPack.BatteryVoltage, out values)) 
            {
                value = (uint)values[0];
                return true;
            }
            else
            {
                value = default(uint);
                return false;
            }
        }

        /// <summary>
        /// Tries to read the <c>battery_charge</c> register value.
        /// Fraction of charge in the battery., _: /
        /// </summary>
        bool TryGetBatteryCharge(out float value)
        {
            object[] values;
            if (this.TryGetRegisterValues((ushort)PowerReg.BatteryCharge, PowerRegPack.BatteryCharge, out values)) 
            {
                value = (float)values[0];
                return true;
            }
            else
            {
                value = default(float);
                return false;
            }
        }

        /// <summary>
        /// Tries to read the <c>battery_capacity</c> register value.
        /// Energy that can be delivered to the bus when battery is fully charged.
        /// This excludes conversion overheads if any., _: mWh
        /// </summary>
        bool TryGetBatteryCapacity(out uint value)
        {
            object[] values;
            if (this.TryGetRegisterValues((ushort)PowerReg.BatteryCapacity, PowerRegPack.BatteryCapacity, out values)) 
            {
                value = (uint)values[0];
                return true;
            }
            else
            {
                value = default(uint);
                return false;
            }
        }

        /// <summary>
        /// Tries to read the <c>keep_on_pulse_duration</c> register value.
        /// Many USB power packs need current to be drawn from time to time to prevent shutdown.
        /// This regulates how often and for how long such current is drawn.
        /// Typically a 1/8W 22 ohm resistor is used as load. This limits the duty cycle to 10%., _: ms
        /// </summary>
        bool TryGetKeepOnPulseDuration(out uint value)
        {
            object[] values;
            if (this.TryGetRegisterValues((ushort)PowerReg.KeepOnPulseDuration, PowerRegPack.KeepOnPulseDuration, out values)) 
            {
                value = (uint)values[0];
                return true;
            }
            else
            {
                value = default(uint);
                return false;
            }
        }
        
        /// <summary>
        /// Sets the keep_on_pulse_duration value
        /// </summary>
        public void SetKeepOnPulseDuration(uint value)
        {
            this.SetRegisterValue((ushort)PowerReg.KeepOnPulseDuration, PowerRegPack.KeepOnPulseDuration, value);
        }


        /// <summary>
        /// Tries to read the <c>keep_on_pulse_period</c> register value.
        /// Many USB power packs need current to be drawn from time to time to prevent shutdown.
        /// This regulates how often and for how long such current is drawn.
        /// Typically a 1/8W 22 ohm resistor is used as load. This limits the duty cycle to 10%., _: ms
        /// </summary>
        bool TryGetKeepOnPulsePeriod(out uint value)
        {
            object[] values;
            if (this.TryGetRegisterValues((ushort)PowerReg.KeepOnPulsePeriod, PowerRegPack.KeepOnPulsePeriod, out values)) 
            {
                value = (uint)values[0];
                return true;
            }
            else
            {
                value = default(uint);
                return false;
            }
        }
        
        /// <summary>
        /// Sets the keep_on_pulse_period value
        /// </summary>
        public void SetKeepOnPulsePeriod(uint value)
        {
            this.SetRegisterValue((ushort)PowerReg.KeepOnPulsePeriod, PowerRegPack.KeepOnPulsePeriod, value);
        }


        /// <summary>
        /// Emitted whenever `power_status` changes.
        /// </summary>
        public event ClientEventHandler PowerStatusChanged
        {
            add
            {
                this.AddEvent((ushort)PowerEvent.PowerStatusChanged, value);
            }
            remove
            {
                this.RemoveEvent((ushort)PowerEvent.PowerStatusChanged, value);
            }
        }


        
        /// <summary>
        /// Sent by the power service periodically, as broadcast.
        /// </summary>
        public void Shutdown()
        {
            this.SendCmd((ushort)PowerCmd.Shutdown);
        }

    }
}