/** Autogenerated file. Do not edit. */
using Jacdac;
using System;

namespace Jacdac.Clients 
{
    /// <summary>
    /// Allows for deployment and control over Jacscript virtual machine.
     /// 
     /// Programs start automatically after device restart or uploading of new program.
     /// You can stop programs until next reset by setting the `running` register to `0`.
     /// 
     /// TODO - debug interface:
     /// * read-globals command/register
     /// * globals-changed pipe
     /// * breakpoint command
     /// * some performance monitoring?
    /// Implements a client for the Jacscript Manager service.
    /// </summary>
    /// <seealso cref="https://microsoft.github.io/jacdac-docs/services/jacscriptmanager/" />
    public partial class JacscriptManagerClient : Client
    {
        public JacscriptManagerClient(JDBus bus, string name)
            : base(bus, name, ServiceClasses.JacscriptManager)
        {
        }

        /// <summary>
        /// Reads the <c>running</c> register value.
        /// Indicates if the program is currently running.
        /// To restart the program, stop it (write `0`), read back the register to make sure it's stopped,
        /// start it, and read back., 
        /// </summary>
        public bool Running
        {
            get
            {
                return (bool)this.GetRegisterValueAsBool((ushort)JacscriptManagerReg.Running, JacscriptManagerRegPack.Running);
            }
            set
            {
                
                this.SetRegisterValue((ushort)JacscriptManagerReg.Running, JacscriptManagerRegPack.Running, value);
            }

        }

        /// <summary>
        /// Reads the <c>autostart</c> register value.
        /// Indicates wheather the program should be re-started upon `reboot()` or `panic()`.
        /// Defaults to `true`., 
        /// </summary>
        public bool Autostart
        {
            get
            {
                return (bool)this.GetRegisterValueAsBool((ushort)JacscriptManagerReg.Autostart, JacscriptManagerRegPack.Autostart);
            }
            set
            {
                
                this.SetRegisterValue((ushort)JacscriptManagerReg.Autostart, JacscriptManagerRegPack.Autostart, value);
            }

        }

        /// <summary>
        /// Reads the <c>logging</c> register value.
        /// `log_message` reports are only sent when this is `true`.
        /// It defaults to `false`., 
        /// </summary>
        public bool Logging
        {
            get
            {
                return (bool)this.GetRegisterValueAsBool((ushort)JacscriptManagerReg.Logging, JacscriptManagerRegPack.Logging);
            }
            set
            {
                
                this.SetRegisterValue((ushort)JacscriptManagerReg.Logging, JacscriptManagerRegPack.Logging, value);
            }

        }

        /// <summary>
        /// Reads the <c>program_size</c> register value.
        /// The size of current program., 
        /// </summary>
        public uint ProgramSize
        {
            get
            {
                return (uint)this.GetRegisterValue((ushort)JacscriptManagerReg.ProgramSize, JacscriptManagerRegPack.ProgramSize);
            }
        }

        /// <summary>
        /// Reads the <c>program_hash</c> register value.
        /// Return FNV1A hash of the current bytecode., 
        /// </summary>
        public uint ProgramHash
        {
            get
            {
                return (uint)this.GetRegisterValue((ushort)JacscriptManagerReg.ProgramHash, JacscriptManagerRegPack.ProgramHash);
            }
        }

        /// <summary>
        /// Emitted when the program calls `panic(panic_code)` or `reboot()` (`panic_code == 0` in that case).
        /// The byte offset in byte code of the call is given in `program_counter`.
        /// The program will restart immediately when `panic_code == 0` or in a few seconds otherwise.
        /// </summary>
        public event ClientEventHandler ProgramPanic
        {
            add
            {
                this.AddEvent((ushort)JacscriptManagerEvent.ProgramPanic, value);
            }
            remove
            {
                this.RemoveEvent((ushort)JacscriptManagerEvent.ProgramPanic, value);
            }
        }

        /// <summary>
        /// Emitted after bytecode of the program has changed.
        /// </summary>
        public event ClientEventHandler ProgramChange
        {
            add
            {
                this.AddEvent((ushort)JacscriptManagerEvent.ProgramChange, value);
            }
            remove
            {
                this.RemoveEvent((ushort)JacscriptManagerEvent.ProgramChange, value);
            }
        }


        
        /// <summary>
        /// Open pipe for streaming in the bytecode of the program. The size of the bytecode has to be declared upfront.
        /// To clear the program, use `bytecode_size == 0`.
        /// The bytecode is streamed over regular pipe data packets.
        /// The bytecode shall be fully written into flash upon closing the pipe.
        /// If `autostart` is true, the program will start after being deployed.
        /// The data payloads, including the last one, should have a size that is a multiple of 32 bytes.
        /// Thus, the initial bytecode_size also needs to be a multiple of 32.
        /// </summary>
        public void DeployBytecode(uint bytecode_size)
        {
            this.SendCmdPacked((ushort)JacscriptManagerCmd.DeployBytecode, JacscriptManagerCmdPack.DeployBytecode, new object[] { bytecode_size });
        }

    }
}